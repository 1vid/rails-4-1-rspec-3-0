# 08. Тестируем фичи


На данный момент мы добавили большое количество тестов в наш менеджер контактов. У нас установлен и настроен RSpec, есть хороший сетап юнит тестов для моделей и контроллеров и сделаны фабрики для создания тестовых данных. Настало время проверить как работает все вместе(интеграционные тесты) — другими словами, проверить как модели и контроллеры работают вместе с другими моделями и контроллерами в приложении. Такие тесты называются "_feature specs_" в RSpec. Так же вы можете встретить название "_acceptance tests_". Создание таких тестов в Rails приложении позволяет протестировать очень широкий спектр функциональности. Так же эти тесты могут быть использованы для воссоздания "баг-репорта" от юзера вашего приложеия.

Есть отличные новости! Вы уже знаете практически все что необходимо для написания надежный интеграционных тестов, их структура очень похожа на ту что мы использовали при тестиовании моделей и контролеров, и так же можно использовать FactoryGirl(Bot) что бы создавать для них данные. И звездой нашего шоу в данный момент будет библиотека ["_Capybara_"](http://teamcapybara.github.io/capybara/), невероятно удобная Ruby библиотека которая помогает разложить тестирование фичи на шаги и симулировать реальное использование вашего приложения.

В той главе мы обратим внимание на следующие вещи:
- Мы начнем с того что подумаем когда и зачем вообще стоит тестировать фичи(делать интеграционные тесты) относительно других способов.
- Далее мы рассмотрим несколько дополнительных зависимостей, которые помогут в интеграционном тестировании.
- Потом мы взглянем на базовые интеграционные тесты.
- Рассмотрим более продвинутые тест которые требуют включений JavaScript.
- Обсудим лучшие практики интеграционного тестирования.

## Зачем нужны интеграционные тесты?

Мы провели кучу времени над тестированием контроллеров. Зачем после всей этой проделанной работы создавать еще один слой тестирования? Потому что тесты контроллеров это относительно простые _unit_ тесты, хоть их тестирование это важный элемент вашего софта, но он покрывает лишь малую часть вашего приложения. Интеграционное тестирование(тестирование фич) имеет значительно больше возможностей, и отражает взаимодействие реального юзера с вашим кодом. Другими словами, такие тесты показываюткак все эти модули, составляющие ваше приложение, интегрируются друг с другом

## Что на счет [Огурца?](https://cucumber.io/)

[Огурец](https://cucumber.io/) это популярная альтернатива тем тестам над которыми нам предстоит поработать в этой главе. Для честности, автор данной книги и сам был ярым приверженцом данной технологии несколько лет но потом маленько остыл, и сей час её не использует. "Огурец" занял свою нишу и имеет право на существование, но так же у него имеется масса издержек. Пока вы серьезно не научились этой технологии, велик риск написать кучу хрупких и в итоге никому не нужных тестов.

Автор понимает ваше желание использовать "Огурец" в случае когда вы работаете напрямую с владельцом проекта(не программистом), который вообще не хочет смотреть на кучу какого то кода. Но по опыту Автора книги, DSL Капибары достаточно понятна что бы не програмист мог понять что происходит в интеграционных тестах.


И если вы если вы не работаете с непрограммистом, то дополнительные накладные расходы, связанные с Огурецом могут не стоить вам дополнительных усилий.

Конечно у Огурца есть масса ярых фанатов. Это один из основных продуктов во многих магазинах для разработчиков, поэтому вам, вероятно, тоже придется с ним ознакомиться в конце концов. Радует шо если вы таки разберетесь с Капибарой и РСпеком на уровне тестирования фич, то вам достаточно просто будет освоить "Огурец".

## :warning:
Тут должна быть ссылка для освоения Огурца, если вы щас с ходу сразу решитесь его освоить, но ссылка из верси книги с которой я работал была не рабочей, все что я смог найти по старому адресу это вот [эта статься](https://www.aslakhellesoy.com/2022/07/04/testing-web-pages.html)

## Дополнительные зависимости

Во 2 главе мы добавили [Capybara](https://github.com/jnicklas/capybara), [DatabaseCleaner](https://github.com/bmabey/database_cleaner) и [Launchy](http://rubygems.org/gems/launchy) в группу `test` в _Gemfile_. Если вы этого еще не сделали, то добавьте, мы наконец будем их использовать.

**DatabaseCleaner** требует кое каких дополнительных настроек, но для начала мы посмотрим на просто спек, без использование _DatabaseCleaner_.

## Базовые спеки фич
Капибара позволяет нам симулировать взаимодействие юзера с нашим приложением через браузер, используя простые и понятные методы, такие как  `click_link`, `fill_in`, `visit`. Помимо того что у этих методов говорящие названия, они еще и описывают сценарий длявашего приложения. Вы мжете предположить что эти спеки будут делать?

**spec/features/users_spec.rb**
```ruby
require 'rails_helper'

feature 'User management' do
  scenario "adds a new user" do
    admin = create(:admin)

    visit root_path
    click_link 'Log In'
    fill_in 'Email', with: admin.email
    fill_in 'Password', with: admin.password
    click_button 'Log In'

    visit root_path
    expect{
      click_link 'Users'
      click_link 'New User'
      fill_in 'Email', with: 'newuser@example.com'
      find('#password').fill_in 'Password', with: 'secret123'
      find('#password_confirmation').fill_in 'Password confirmation',
        with: 'secret123'
      click_button 'Create User'
    }.to change(User, :count).by(1)
    expect(current_path).to eq users_path
    expect(page).to have_content 'New user created'
    within 'h1' do
      expect(page).to have_content 'Users'
    end
    expect(page).to have_content 'newuser@example.com'
  end
end
```

Пройдемся по спеку:
- Сначала создается новый админ `admin = create(:admin)` (юзер который может создавать юзеров)
- Затем используется логин форма для входа админа, и происходит создание нового юзера, с использованием той ж формы, в которой реальные админы вашего приложения делали бы это. Это важное различие между спеком контроллера и спком фичи. В спеке контроллера мы обхдим юзерский интерфейс и напрямую отправляем параметры в метод контроллера, а в данном случае(спеке фичи) мы используем несколько контроллеров и экшенов `contacts#index`, `sessions#new`, `users#new`, и `users#create`.
- Тем не менее результат будет такой же. Будет создан новый юзер, приложение средиректит нас на список всех юзеров, отрендерится флеш сообщение о том что все прошло успешно, и новый юзер появится в списке юзеров на странице.

Вы так же могли отметить что мы используем такие же примеры как в прошлых главах: `feature` использовано вместо `describe` для структурирования спека, `scenario` описывает конкретный пример вместо `it`, и _Proc_ `expect{}` с которым мы разобрались в главе 5 выполняет здесь такую же роль, мы выдвигаем предположение что некоторые вещи изменятся когда юзер выполнит некоторые действие(заскриптованый нами в спеке сценарий) взаимодействуя с нашим приложением.

Обратили внимание на использование `find('#password')` и `find('#password_confirmation)`? Как вы могли предположить, этот метод(`find`) _находит_ на странице которая рендерится, используя любой аргумент который вы ему передадите(не путайте с одноименным методом который нам предостовляет **ActiveRecord**). Метод о котором мы говорим находит нужные элементы по CSS—<div> элементы по их `id`'шникам. Так же мы можем искать элементы по [XPath расположению](https://github.com/teamcapybara/capybara#xpath-css-and-selectors), или даже просто по текстовому значению как это сделано для `click_link 'Users'`, `fill_in 'Email'`. Не смотря на это, тесты могут упасть если значение переданной в аргумент будет двусмысленным(не однозначным), например если сделать вот так:

```ruby
fill_in 'Password', with: 'secret'
fill_in 'Password confirmation', with: 'secret'
```

Скидыщ! И Капибара кинет в нас _Ambiguous match_ ошибку, потому что слово _Password_ использовано в двух разных строках. И если прилетает такая ошибка то надо перебирать вьюху которая рендерит нужный элемент страницы и искать альтернативные варианты размещения этого поля с которым вы хотите повзаимодействовать.

Если есть возможность, автор предпочитает простые текстовые матчеры, затем CSS. Если ни один из этих вариантов не подходят, то воспользуемся матчерами основанными на _XPath_. Глянтье обязательно официальный [README](https://github.com/teamcapybara/capybara/blob/master/README.md#using-capybara-with-rspec) Капибары.

## :warning:
Так же метод `find` очень полезен для тестирования интерфейсов с включениями _JavaScript_. Больше об этом поговорим в этой главе.

Продолжим с `expect{}`, мы запускаем серию тестов для того что бы убедится что результирующая въюха отображает именно то что мы предположили, используя для этого DSL Капибары. Как вы видите, это уже не совсем чистый английский, но по прежнему достаточно легко разобратся с тем что происходит в спеке. Так же стоит обратить внимание на блок `within` используемый для указания блока для поиска конкретного контента, в данном случае в тег `<h1>` в `index` въюхе для пользователей. Это альтернатива для метода `find()` например что бы определить поля `password` и `password confirmation`. Можете поэкспериментировать с этим, но чуть позже мы рассмотрим это более подробно.

Заключтельная вещь которую мы рассмотрим в данном блоке: В тесте одной фичи очень резонно использовать несколько предположений в данных примерах или сценариях. Спеки фич требуют от разработчика намного больше времени и внимания относительно юнит тестов, и конечно требуют большего количества настроек. Например в предыдущем спеке автор мог бы захотеть проверить появление флеш сообщения при успешном логине пользователя, но на самом деле такой тест будет более уместен в спеке посвященном механизму аутентификации в нашем приложении.

## От запросов к фичам

В ноябре 2012, Capybara 2.0 представила несколько изменений в DSL, включающие вышеупомянутое использование термина `feature` вместо `request`. `request` спеки по прежнему имеют место быть, но предназначены для любого общедоступного(публичного) API, которое может быть подключено к вашему приложению.

В дополнение к смене расположения этих спеков, в Capybara 2.0 представлены несколько новых "названий" блоков что бы спеки фич выглядели бы похоже на `acceptance` тесты, написаные в других фреймворках(типа Огурца). Эти "названия" (уточнение: вышеупомянутые `feature` и `scenario`) используются исключительно для спеков фич. Другие же "названия" использующие `background` для `before` и `given` для `let` (мы их используем в главе 9).

Строго говоря, вы можете использовать `describe` и `it` в ваших интеграционных тестах, но для лучших результатов, автор настоятельно рекомендует использование нового DSL Капибары. Именно так мы будем описывать примеры для нашей адресно книги продвигаясь все дальше.

## Добавление тестов фич

Самый быстрый способ создать новый спек фичи в вашем приложении, это создание файла внутри _spec/features_, по следующему шаблону:

```ruby
require 'rails_helper'

  feature 'my feature' do
    background do
      # add setup details
    end

  scenario 'my first test' do
    # write the example!
  end
end
```


## :warning:

> Если использовать скаффолд генератор для создания моделей и ассоциированных с ними контроллеров, въюх, миграций и спеков, соответствующие спеки фич появятся в _spec/requests_. Необходимо будет удалять их или перемещать в _spec/features_ и редактировать. Но можно и отключить такую "услугу", нужно прописать `request_specs: false` в _application.rb_ в месте с Rspec генератором.

## Дебажим спеки фич
  
Мы уже упоминали ранее о том, когда у нас несколько предположений в рамках одного сценария это достаточно типичная ситуация для спека фичи. Хотя иногда такой подход может заставлять вас задуматся а почему именно здесь упал тест. В большенстве случаев вы можете пользоватся стандарнтными инструментами для дебага Ruby приложений в рамках RSpec — но один из самых простых это [_Launchy_](https://github.com/copiousfreetime/launchy). Launchy включен в Capybar'у как зависимость, и делает там одну единственную вещь: Сохраняет HTML текущего теста фичи во временный файл и рендерит его в вашем дефолтном браузере.

Что бы использовать Launchy в спеке, надо добавить одну строку:

```ruby
save_and_open_page
```

Например в спеке фичи которую мы смотрели ранее, автор добавляет Launchy что бы посмотреть результаты формы нового юзера:

**spec/features/users_spec.rb**
```ruby
require 'rails_helper'

feature 'User management' do
  scenario "adds a new user" do
    admin = create(:admin)
    sign_in admin

    visit root_path
    expect{
      click_link 'Users'
      click_link 'New User'
      fill_in 'Email', with: 'newuser@example.com'
      find('#password').fill_in 'Password', with: 'secret123'
      find('#password_confirmation').fill_in 'Password confirmation',
      with: 'secret123'
      click_button 'Create User'
    }.to change(User, :count).by(1)

    save_and_open_page

    # remainder of scenario
  end
end
```

Можем теперь удалить `save_and_open_page` т. к. он больше не нужна.

## Небольшой рефакторинг

Перед тем ка двигатся дальше, взглянем на другой спек фичи создания новых юзеров. Как вы помните, в 7 главе мы вынесли симуляцию логина юзера в макро-хелпер. Мы можем использовать такую технику и для спеков фич.

Почему просто не использовать такую же технику как для спеков контроллеров? Потому что на уровне интеграционных тестов, мы тестируем те же вещи, но со стороны взаимодействия юзера с ними. И это включает в себя вход в приложение(_logining in_)! Как раз это вход в приложение мы можем вынести в макро-хелпер:

**spec/support/login_macros.rb**
```ruby
module LoginMacros
  # controller login helper omitted ...

  def sign_in(user)
    visit root_path
    click_link 'Log In'
    fill_in 'Email', with: user.email
    fill_in 'Password', with: user.password
    click_button 'Log In'
  end
end
```

Мы можем использовать этот хелпер в нашем спеке вот так:

**spec/features/users_spec.rb**
```ruby
feature 'User management' do
  scenario "adds a new user" do
    admin = create(:admin)
    sign_in admin

    # remaining steps omitted ...
  end
end
```

## Подключаем взаимодествие с JavaScript

Итак мы проверили при помощи нашего спека, что интерфейс для добавления контактов работает так, как было запланировано. Теперь давайте протестим ссылку _About_ в навбаре нашего приложения.

Сначала эта задача кажется достаточно простой, но по факту это норм заморочка для наших тестов.

Спек буде выглядеть примерно так:

**spec/features/about_us_spec.rb**
```ruby
require 'rails_helper'

feature "About BigCo modal" do
  scenario "toggles display of the modal about display" do
    visit root_path

    expect(page).not_to have_content 'About BigCo'
    expect(page).not_to \
      have_content 'BigCo produces the finest widgets in all the land'
    
    click_link 'About Us'

    expect(page).to have_content 'About BigCo'
    expect(page).to \
      have_content 'BigCo produces the finest widgets in all the land'
    within '#about_us' do
      click_button 'Close'
    end
    
    expect(page).not_to have_content 'About BigCo'
    expect(page).not_to \
      have_content 'BigCo produces the finest widgets in all the land'
  end
end
```

Ничего суперсложного, но это проблема. Мы запускаем спек фичи использую дефолтный вебдрайвер Капибары. Это драйвер, **Rack::Test**, не может интерпритировать **JavaScript**, по этому игнорирует его. Следовательно, самое первое предположение в примере упадёт, потому что без JavaScript'а будет спрятан встроеный _div_ `#about_us` в файле **application.html.haml**, Rack::Test увидит div и репортнет ошибку.

К счастью, Capybara поддерживает веб-драйвера Selenium из коробки. С Selenium'ом вы можете симулировать более сложные веб взаимодествия, включая JavaScript, но должен быть установлен Firefox. Selenium делает это возможным запуская код с вашими тестами через легковесный веб сервер и автоматизирует взаимодействие браузера с этим сервером.

## :warning:

К сожалению, Selenium добавляет одну зависимость не завязаную на Ruby:
это FireFox. Политика Mozilla Foundation по частому обновлению браузера
однажды поломает ваши тесты. Как случилось у меня(windows10, wsl2), автора заметок:

```
About BigCo modal

  An error occurred in an after hook
    Selenium::WebDriver::Error::WebDriverError: unable to obtain stable firefox connection in 60 seconds (127.0.0.1:7055)
    occurred at /usr/share/rvm/gems/ruby-2.1.1/gems/selenium-webdriver-2.43.0/lib/selenium/webdriver/firefox/launcher.rb:79:in `connect_until_stable'

  toggles display of the modal about display (FAILED - 1)

User management

  An error occurred in an after hook
    Selenium::WebDriver::Error::WebDriverError: unable to obtain stable firefox connection in 60 seconds (127.0.0.1:7055)
    occurred at /usr/share/rvm/gems/ruby-2.1.1/gems/selenium-webdriver-2.43.0/lib/selenium/webdriver/firefox/launcher.rb:79:in `connect_until_stable'

  adds a new user (FAILED - 2)
```

Это серьезная загвоздка, браузер обновляется, а старые приложения рабтают на старых версиях руби, автор рекомендует просто обновить гем, но обновленный гем не совместим со старой версией руби. То есть как вариант можно снизить версию браузера, тесты будут проходить но на старой версии браузера, а клиенты будут использовать новую...

Продолжим. Что бы использовать Selenium, внесем небольшое изменение в код:

**spec/features/about_us_spec.rb**
```ruby
require 'rails_helper'

feature "About BigCo modal" do
  scenario "toggles display of the modal about display", js: true do
    # the example ...
  end
end
```

Посмотрим в чем разница: При добавлениии `js: true` в сценарий, это говорит Capybar'е использовать совместимый с JavaScript драйвер(по умолчанию Selenium). Вот и все впринципе. Запускаем спек снова, и мотрим как запускается Firefox и отрабатывает все шаги по сценарию.

Согласитесь, эо был очень просто пример. Для наглядности давайте рассмотрим пример с большим вовлечением юзера во взаимодействие через Selenium. Первый сценарий, который мы создали в этой главе, не требует JavaScript для выполнения, давайте все равно включим его и посмотрим, что произойдет.

**spec/features/users_spec.rb**
```ruby
feature 'User management' do
  scenario "adds a new user", js: true do
    # scenario steps ...
  end
end
```

Так же нам необходимо настроить _Database Cleaner_ что бы помочь с транзакциями базе данных в наших тестах. Давайте внесем следующие изменения в _spec/rails_helper.rb._. Автор взял их прям из официального README DatabaseCleaner'а по RSpec:

**spec/rails_helper.rb**
```ruby
RSpec.configure do |config|

  # earlier configurations omitted ...
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with :truncation
  end

  config.around(:each) do |example|
    DatabaseCleaner.cleaning do
    example.run
  end
end

  config.after(:each) do
    DatabaseCleaner.clean
  end

  # additional RSpec configuration omitted ...
```

Шо здесь происходит? Сначала мы фиксируем стратегию(_strategy_) котрую мы будем использовать при создании тестовых данных. Для изоляции тестов (одного от другого в рамках одного спека), выбираем _transaction_([SQL transaction](https://docs.microsoft.com/ru-ru/sql/t-sql/statements/set-transaction-isolation-level-transact-sql?view=sql-server-ver16)) статегию, которая обрабатывает каждый сетап в транзакциях базыданных. Затем мы говорим DatabaseCleaner'у чистить данные используяю "усечения SQL"([SQL truncation](https://docs.microsoft.com/en-us/sql/t-sql/statements/truncate-table-transact-sql?view=sql-server-ver16)). И наконец, мы определяем границы транзакции(вокруг каждого примера в комплекте тестов) и когда запускать очистку(после окончания каждого примера).

Далее нам необходимо проманкипатчит ActiveRecord(?!) для использования тредов(?!). Добавим файл в _spec/support_ со следующими изменениями  ActiveRecord::Base:

**spec/support/shared_db_connection.rb**
```ruby
class ActiveRecord::Base
  mattr_accessor :shared_connection
  @@shared_connection = nil

  def self.connection
    @@shared_connection || retrieve_connection
  end
end
ActiveRecord::Base.shared_connection = ActiveRecord::Base.connection
```

Зачем это вобще надо?! Короткий ответ: это связано с тем как Selenium обрабатывает транзакции базы данных. Нам необходимо расшарить данные через Selenium веб сервер и сам код тестов. Без DatabaseCleaner'а и патча который мы сделали выше, у нас будут спонтанно появлятся ошибки что после тестов не была произведена должная очистка.

С этими изменениями, интеграционные тесты будут работать через FireFox. Мы еще на один шаг ближе к приложению хорошо покрытому тестами. DatabaseCleaner предоставляет множество других опций на отраженных в книге. В зависимости от ваших потребностей в тестировании, тип вашей БД(_напр._ реляционная, document-based...), ваш ORM (_напр._ ActiveRecord, Mongoid, Sequel), может вы захотите внести еще какие то коррективы. Всегда есть под рукой официальны [README DatabaseCleaner'а](https://github.com/DatabaseCleaner/database_cleaner).

Было хорошо и в этом приложении вам поэкперементировать с конфигом DatabaseCleaner'а. Это хорошая возможность проверить на хрупкость свои тесты.

## Драйверы Капибары 

Мы уже подключили дв драйвера для работы наших интеграционных тестов. По умолчанию в рельсе работает RackTest - это надежное решение для тестирования базовых взаимодействий браузера с приложением. Но он работает при помощи запросов(_headless_, , _"без морды"_), все симуляции взаимодействий происходят "под капотом"(_в фоновом режиме_). При помощи Selenium'а можно протестить более сложные взаимодействия,включая JavaScript и всевозможные редиректы(в т.ч. и за пределы вашего приложения).

У добавления функционала которы появляется при использования Seleniuma'а, есть своя цена — сильно замедляются тесты, запаритесь кажды раз ждать пока запустится FireFox, особбено если ваши интеграционные тесты все время будут расти. К счастью есть и _headless_ драйверы которые умеют работать с JavaScript. Два популярных для Capybar'ы, это [capybara-webki](https://github.com/thoughtbot/capybara-webkit) и [Poltergeist](https://github.com/teampoltergeist/poltergeist)

Для обоих этих драйверов могут потребоватся дополнительные зависимости и их установка может занять какое то время, но если в вашем приложени куча интеграционных тестов(_feature specs_) требующих больше чем базовые взаимодействия которые предоставляет RackTest, стоит заморочится, это сэкономит вам время в будущем. Го на [офф доку Капибары](https://github.com/teamcapybara/capybara) чтоб посмотреть доп настройки для рабты с различными драйврами.

## Ожидание JavaScrit

Ранее в этой главе, автор упомянул что метод `find` У Capybar'ы очень полезен при тестировании JavaScript. `find` будет ждать пока не произойдет совпадение указанное вами место в спеке, для взаимодействия с ним. Например, мы могли бы использовать следующее вариант поиска, чтобы дождаться появления кнопки:

```ruby
find_button('Close').click
```

По дефолту Капибара ждет две секунды, потом сдается)) Но можно кастомизировать это время по вашему желанию:

```ruby
Capybara.default_wait_time = 15
```

так время ожидания будет 15 секунд


Вы можете включить это в свой файл _rails_helper.rb_, чтобы применить настройку ко всем вашим тестам или для каждого отдельного примера.

## Заключение

Это была не такая уж большая глава, особенно по сравнению с тем сколько мы сидели над контроллерами. Но! это было вступление со множеством новых концепций которые опираются на все что мы изучили к этому моменту. Перечитайте и пересмотрите все несколько раз, если чего то не поняли, и практикуйтесь. Если вы где то застряли это норм, залезте в свой браузер и посмотрите что там происходит, соответствует ли это вашим предположениям?(в этом кстати поможет Launchy)

На этом этапе мы уже ознакомились с основными инструментами и техниками которые мы будетем использовать для тестирования наших Rails приложений. Хотя у нас есть несколько вещей которые надо обсудить, до того как закончить. В следующей главе мы обсудим как максимально ускорить ваши тесты, на сколько это вообще возможно.