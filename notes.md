# 09. Ускоряем спеки

Если вспомнить главу 7, мы рефачили спеки контроллеров, чтобы их проще было писать и поддерживать. Конкретно мы ставили перед собой следующие ти задачи:

- Мы снизили избыточность(повторяемость кода) используя расшаренные примеры([shared examples](https://relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples))
- Мы перенесли часто используемы функции в макрос-хелперы
- Мы кастомизировали матчеры для упрощения наших предположений для наших примеров.

Тперь у нас есть отностельно готовый пакет тестов, давайте на него взглянем снова и подумаем как мы можем его отрефакторить — только для ускорения.

Под ускорнием, автор предпологает 2 вещи: 
- Первое, это конечно время которое проходить с начала запуска тестов до их завершения. Тесты нашего небольшого приложения уже начинают заметно замедлятся. Если предположеть что приложение будет расти, и с ним будет расти пакет тестов, они будут работать все медленнее и медленнее, если не держать их в "узде". Цель заключается в том что бы сохранить вменяемую скорость прохождения тестов, не жертвуя хорошей читаемостью тестов которую нам предоставляет RSpec.  
- А второе, это ваша скорость как разаработчика, при написании понятных, полных смысла, незахламленных тестов.

Мы коснемся в этой главе обоих аспектов. Конкретно мы рассмотрим:

- Возможности лаконичного и чистого синтаксиса RSpec для сокращения спеков.
- Упрощение спеков при помощи кастомных [Shoulda матчеров](https://github.com/thoughtbot/shoulda-matchers)
- Повышение эффективности даннх для тестирование с использованием [моков и стабов](https://relishapp.com/rspec/rspec-mocks/docs)
- Использование тэгов для фильтрации медленных спеков.
- Автоматизация выполнения тестов и предварительная загрузка Rails.
- Как в целом ускорить работу тестов(приемчики от автора книги)

## Опционально, сокращение синтаксиса

Можно покритиковать все что мы данный ммент сделали в многословности — но мы использовали несколько лучших практик и использовали ясные понятные названия(лейблы) для каждого теста, а так же одно предположение на один пример. Все это было сделано намеренно. Такой явный подход которым мы воспользовались, точно такой же какой автор использовал во время изучения написания тестов, по его мнению это хорошенько помогает понят что происходит. И вместе с тем, Rspec предоставляет техники которые помогут еще лучше развить эти практики, что позволит сократить ваше время за клавиатурой. Они могут быть использованы вместе для совершенной рацонализации, или в частности для сокращения длиннющих спеков при необходимости.

### let()

Ранее мы использовали `before :each` блоки чтобы назначить часто используемые данные в инстанс переменные. Альтернатива этого, предпочтительная кстатит для RSpec, это использование `let()`. 

`let()` даёт нам два приемущества: 

1. Кэширует значение без присвоения этого значения инстанс переменной.
2. `let()` это _lazy evaluated_ метод, это означает что пока спек не обратится к этому методу никаких значений не будет.

Вот как мы можем использовать `let()` в спеке контроллера:

**spec/controllers/contacts_controller_spec.rb**
```ruby
require 'rails_helper'

describe ContactsController do
  let(:contact) do
    create(:contact, firstname: 'Lawrence', lastname: 'Smith')
  end

  # rest of spec file omitted ...
```

Теперь вместо работы с инстанс переменной `@contact`, мы можем использовать `contact`:

**spec/controllers/contacts_controller_spec.rb**
```ruby
describe 'GET #show' do
  it "assigns the requested contact to contact" do
    get :show, id: contact
    expect(:contact).to eq contact
  end

  it "renders the :show template" do
    get :show, id: contact
    expect(response).to render_template :show
  end
end
```

И вместе с тем такой подход может вызвать проблемы где мы тестируем метод контроллера `destroy()`, он как бы удаляет уже существующий в бд объект. Вот пример который упадет:

**spec/controllers/contacts_controller_spec.rb**
```ruby
describe 'DELETE destroy' do
  it "deletes the contact" do
    expect{
      delete :destroy, id: contact
    }.to change(Contact,:count).by(-1)
  end
end
```

`count`(количество записей) здесь не изменится, т.к. в данном случае не известно что такое `contact` до момента его вызова в Proc'e `expect{}`. Что бы это пофиксить нам достаточно вызвать `contact` в примере до вызова Proc'a:

**spec/controllers/contacts_controller_spec.rb**
```ruby
describe 'DELETE destroy' do
  it "deletes the contact" do
    contact
    expect{
      delete :destroy, id: contact
    }.to change(Contact,:count).by(-1)
  end
end
```

Так же мы можем использовать `let!()` (_обратите внимание на восклицательный знак_), тогда `contact` будет присвоено значение автоматом перед каждым примером. Такой же функционал будет если мы включим `let()` в блок `before` но тогда теряется смысл использования `let()`.

### subject{}

`subject{}` позволяет нам объявить тестируемый субьект, а затем неявно использовать его в любом количестве последующих примеров. Далее будут примеры его использования.

### it{} и specify{}

`it{}` и `specify{}` это снонимы это просто блоки которые включают в себя предположения. Мы использовали `it{}` начиная с 3 главы, только в более развернутой форме. Другими словами вам необходимо заменить:

```ruby
subject { build(:user, firstname: 'John', lastname: 'Doe') }

it 'returns a full name' do
  should be_named 'John Doe'
end
```

на

```ruby
subject { build(:user, firstname: 'John', lastname: 'Doe') }
it { is_expected.to be_named 'John Doe' }
```

И получим тот же результат. Возможно здесь это выглядит тривиално, но по мере роста тестовой баз one-liner'ы могут имет большое значение и разница будет ощутима.

Читайте ваши спеки вслух когда их пишите, используйте термины которые отражают суть происходящего(смысл). Тут нет жестких правил когда использовать тот или иной вариант.

## Shoulda

[Shoulda](https://github.com/thoughtbot/shoulda) это внушительная библиотека хелперов которая превращает обычный функционал тестирования в легкий морской бриз))Подключив этот гем, мы можем сократить количество строк в нашем спеке с пяти до одной-двух.

`subject()`, `it{}` и `specify{}` реально начинаю сиять когда используются совместно с `shoulda-matchers` гемом. Подключаем `shoulda-matchers` в группу `:test` в Gemfile'e, и автоматически получаем доступ к огромному количеству очень полезных матчеров, например:

```ruby
subject{ Contact.new }
it { is_expected.to validate_presence_of :firstname }
```

Лаконично и понятно, обеспечивает хорошее покрытие. Мы также можем забабахать свои собственные матчеры для еще большей оптимизации. Например:

```ruby
RSpec::Matchers.define :be_named do |expected|
  match do |actual|
    actual.name eq expected
  end

  description do
    "return a full name as a string"
  end
end
```

Такой матчер легко можно использовать в `it{}` блоке:

```ruby
it { is_expected.to be_named 'John Doe' }
```

Этт пример конечно может показатся очень вычурным, но он дает представление как пользоватся этим. Автор надеется что у вас могут появтся идеи как использовать свои матчеры что бы оптимизировать ваши тесты и они бы по прежнему оставались читабельными. Например:

```
Contact
  should return a full name as a string
  should have 3 phones
  should require firstname to be set
  should require lastname to be set
```

и так далее.

## Моки и стабы (_Mocks and stubs_)

Моккинг и стаббинг, и концепция которая заключается в них, может быть предметом очень длинной главы или даже целой книги. если вы погуглите про них, вы неизбежно наткнетесь на споры о правильном и неправильном их использовании. Так же вы найдете какое то количество людей которые хотя дать определение этим двум терминам, с переменным успехом. По мнению автора вот два лучших определения:

- `Mock` это объект, который представляет собой реальный объект, для нужд тестирования. Так же известный как тестовый дубль(_test doubles_). Это что то типа того как мы используем Factory Girl, за тем исключением что `mock` не обращается в базу данных, и соответственно занимает меньше времени для настройки и запуска тестов. 

- `Stub` перезаписывает метод который вызывается у данного объекта, и возвращает предопределённое значение когда этот метод у обекта вызывается. Другими словами `Stub` это фейковый метод, который при вызове, возвращает результат который используется в нашем тесте. Вы будете обычно его использовать для переопределения дефолтной функциональности метода, особеноо по тем которые обращаются в баз данных или определяют интенсивность взаимодействия с сетью.

Вот парочка рандомных примеров:

- Что бы создать `mock` контакта, мы можем использовать метод Factory Girl `build_stubbed()` он создаст фйковый обект-заклушку, знающую как ответить на методы `firstname`, `lastname`, и `fullname`. Но он не будет содержатся в базе данных.

- Что бы сделать `stub` методу модели `Contact`, вам необходимо использовать "заглушку" в строке `allow(Contact).to receive(:order).with('lastname, firstname').and_return([contact])`. Таким образом мы перезаписываем порядок обращения в бд у модели Contact(_`order` scope_). Мы передаем строку, чтобы указать порядок SQL запроса (в данном случае поля фамилии и имени), а затем сообщаем, что мы хотим вернуть — одноэлементный массив, содержащий контакт, который мы предположительно создали ранее в спеке.

Во многих случаях предпочтительнее поискать встроенные в [Rspec библиотеки моков](rubydoc.info/gems/rspec-mocks/frames) или сторонних библиотек типа [Mocha](https://rubygems.org/gems/mocha), можно глянуть на [руби тулбоксе другие либы](https://www.ruby-toolbox.com/categories/mocking). С точки зрения начинающего разработчика, они все примерно работают одинаково, но есть небольшие но важные компросмисы.

Щас наглядно посмотрим как это выглядит в спеке контроллера, для лучшего понимания:

**spec/controllers/contacts_controller_spec.rb**
```ruby
describe 'GET #show' do
  let(:contact) { build_stubbed(:contact,
    firstname: 'Lawrence', lastname: 'Smith') }

  before :each do
    allow(Contact).to receive(:persisted?).and_return(true)
    allow(Contact).to receive(:order).with('lastname, firstname').and_return([contact])
    allow(Contact).to receive(:find).with(contact.id.to_s).and_return(contact)
    allow(Contact).to receive(:save).and_return(true)

    get :show, id: contact
  end

  it "assigns the requested contact to @contact" do
    expect(assigns(:contact)).to eq contact
  end

  it "renders the :show template" do
    expect(response).to render_template :show
  end
end
```

Пройдемся по спеку, сперва мы используем `let()` что бы записать контакт-заглушку(`mock`) в `contact`. Затем добавим пару заглушенных метода(`stub`) в модель Contact и переменную `contact`. Поскольку контроллер будет ожидать, что и `Contact`, и `contact` будут реагировать на несколько методов ActiveRecord, нам необходимо заглушить методы, которые мы будем использовать в данном контроллере, что бы они возвращали контроллеру то что мы ожидаем от ActiveRecord. И наконец, мы используем `it` блоки непосредственно для примеров, так же как мы делали на протяжении всей книги. В данном случае все наши тестовые данные находятся в моках и стабах и не обращаются ни к базе данных, ни к непосредственно модели `Contact`.

Из плюсов, эти примеры более изолированы чем спеки написаные ранее, они взаимодействуют исключительно с указаными методами контроллера. Тут отстутсвует проверка на уровне модели или на уровне базы данных или еще чего то. Из минусов, то что такая изоляция требует дополнительного объема кода и сомнительную читаемость в нашем спеке.

Учитывая все вышесказанное, если не хотите запариватся со стабами и моками(заглушками), не парьтесь - вы можете спокойно использовать объекты Ruby для базовых вещей и использовать фабрики для более сложных вещей, так же как мы делали на протяжении все книги. Стабы несомненно прибавят вам головной боли. Очень легко можно случайно перекрыть важную функциональность и в результате ваш тест будет тестировать ровным счетом ничего.

Короче разумное использование объектов и фабрик это по сути все что вам нужно. За исключением случаев если уж прям очень все начинает тормозить или приходится работать с трудновоспроизводимыми данными(например, внешний API или другой веб-сервис, об этом мы поговорим поподробнее в следующей главе).

## Автоматизация с Guard и Spring

Если не сразу и не часто запускать тесты, можно потерять кучу времени. Так же если вы не понимаете где в тестах проблема, и пытаетесь сверху накидать еще пару спеков,тоже съест кучу вашего времени. Переключатся на терминал и запускать `bin/rspec` тоже может быть утомительно и схавает драгоценное время. Но нам поможет [Guard](https://github.com/guard/guard).

Guard за указаными вами файлами, и работает основываясь на том что видит. В нашем случае мы хотим ему показать файлы в директориях _app_ и _spec_. И запускать соответствующие спеки при изменении файлов. Например, если внести изменения в _app/models/contact.rb_, то должен запуститься _spec/models/contact_spec.rb_. И если спек упал, то он будет срабатывать на этот файл пока тест не пройдет успешно. 

Что бы использовать Guard, надо разместить в Gemfile'e `guard-rspec` в группах `:test` и `:developement`. 

А затем создать `Guardfile` используя командную строку:
```
guard init rspec
```

Эта команда сгенерит Guardfile в руте(корневой директории) нашего приложения, это файл будет Guard'овским конфигом для нашего приложения. Guard предоставляет обширный функционал уже из "коробки", но возможно вам захочется его поднастроить под свои нужды. Обычно делают слудющее:

- `notification: false`: автор предпочитает видеть как спеки отрабатывают в терминале вместа того что бы смотреть на всплывающие сообщения.

- `all_on_start: false` и `all_on_pass: false`: автор делает это на время. Необходимо запускать весь пакет тестов перед коммитом внесенных изменений. Если я хочу запустит свои спеки в любое время,после запуска Guard, нужно нажать _return_(_enter_). То же самое с запуском тестов во время их(_upon_) прохождения, позволяет сохранять контроль над ситуацией. 

- Запуск интеграционных тестов после изменений во вьюхе — такого подхода придерживается Аарон Самнер с тех пор как стал избегать тестирования вьюх при помощи RSpec, и стал пологатся на интеграционное тестирование при помощи Капибары на этом уровне. Он честно признается что не запускает интеграционные тесты при изменении моделей и контроллеров. Конечно в зависимости от ситуации.

Запустим `guard` что бы посмотреть что же все таки происхдит. Guard запустит весь набор имеющихся тестов, а затем будет наблюдать за изменениями в файлах, и при сохранении изменений будет автоматом запускать соответствующие тесты. Вы можете подключить и другие опции, на пример: запуск полного пакета тестов исключительно по запросу(вариант предпочтитамый автором). Что бы реализовать это, добавьте след строку в _Guardfile_:

**Guardfile**
```ruby
guard :rspec, cmd: 'rspec --color --format documentation',
  all_on_start: false, all_after_pass: false do
```

## :warning:
Guard может не только следить за изменениями в файлах и запускать тесты. Он так же может компилировать Saas и LESS в CSS, запускать фичи Cucumber'а, [сокращать JS](https://github.com/smgt/guard-minify), запускать метрики кода, перезагружать сервисы в дев окружении и много чего еще. Гляньте [гитхаб guard'a](https://github.com/guard).

После запуска тесты проходят достаточно быстро. Но у нас есть лаг в когда мы только начинаем, это связано с тем что рельсам надо разогняться каждый раз. Со Spring'ом, который встроен в рельсу 4.1, задержка будет происходить лишь раз, при запуске полного пакета тестов, потом тесты будут запускатся независимо от разгона рельсы. Использование Guard и Spring это одно из лучших решений для сокращения времени на тестирование, без переписывания тестов.

Нам нужно сделать небольшой сетап что бы Rspec работал вместе со Spring. Добавим поддержку команды `bin/rspec` в Spring. Это делается путем добавления гема:

**Gemfile**
```ruby
group :development, :test do
  gem 'spring-commands-rspec', '~> 1.0.2'
  # ...
end
```

Убедимся что новая `bin/rspec` команда доступна как _binstub_:

```
$ spring binstub rspec
$ spring stop
```

Теперь мы можем указать загрузку _Rspec_ через _Spring_ в _Guardfile'е_:

**Guardfile**

```ruby
guard :rspec, cmd: 'spring rspec --color --format documentation',
  all_on_start: false, all_after_pass: false do
```

## Тэги

Будете вы добавлять Guard в ваш рабочий процесс или нет, решать вам. Что бы запускать конкретные примеры можно использовать [Rspec'овские теги](https://relishapp.com/rspec/rspec-core/v/2-4/docs/command-line/tag-option). Покажем на примере как применять тэг:

```ruby
it "processes a credit card", focus: true do
# details of example
end
```

Теперь можно запускать спеки только с тегом `focus`:

```
$ rspec --tag focus
```

Если вам показалась эта фича полезной, вы возможно захотите добавить еще `run_all_when_everything_filtered` в конфиг вашего Rspec. Это позволит запускать все спеки где нет примеров с тегами:

**spec/rails_helper.rb**
```ruby
RSpec.configure.do |config|
  config.run_all_when_everything_filtered = true
end
```

Так же вы можете настроить RSpec что бы запускались(или не запускались) только примеры с конкретным тегом, например:

**spec/rails_helper.rb**
```ruby
RSpec.configure do |config|
  config.filter_run focus: true
  config.filter_run_excluding slow: true
end
```

Это особенно полезная штука при использовании Guard, можно включить или выключить какие то теги в _rails_helper.rb_ файле, позволяя Guard'у перезагрузить себя, и оставатся в работе. Не часто эта фишка используется но если нужен тако функционал то она не заменима.

## Другие решения по ускорению

### Удалите не нужные тесты

Если вы уверены что тест отработал свое и уже не нужен вам удалите его, если сомневаетесь поставьте `skip` что бы он не запускался:

```ruby
it "loads a lot of data" do
  skip "no longer necessary"
  # your spec's code; it will not be ru
end
```

Автор рекомендует использовать этот подход вместо комментирования. Когда кажды раз призапуске тестов они будут высвечиватся как _pending_ вы вряд ли про них забудете и потеряете мусорный кусочек кода. Так же автор настаивает все таки избавлятся по возможности от не нужных кусочков.

В более ранних версия RSpec этот функционал предоставлялся методом `pending`. Он так же остался в RSpec 3, но работает несколько иначе. Теперь спек помеченный `pending` по прежнему будет запускатся, если тест упадет отобразится _pending_. Но если тест будет проходить то он отметится как _failure_.

## Убераем Rails из уравнения

Изменения которые мы перечислили выше, все сокращают время прохождения тестов, но самое главно что тормозит тесты это непосредственно Rails, призапуске тестов запускается какая то часть или весь фреймворк. Если вы _серьёзно_ ускорить прохождение тестов, вы можете делать все возможн что бы исключить Rails из процесса. Спринг вот позволяет заводить рельсы лишь раз, это нас уже приближает к цели.

Эта тема обширнее чем смысловое поле этой книги, решение может лежать уже в архитектуре вашего приложения. Так же рассмотрение этих вопросов ломает правило Автора ("не отклонятся от соглашения(convention) при работе с начинающими разработчиками насколько это возможно"). Но если вам дико любопытно взгляните на следующие ресурсы:

- [Выступление по теме от Corey Haines](https://www.youtube.com/watch?v=bNn6M2vqxHE) 

- [Скринкасты от Gary Bernhardt "Destroy All Software"](https://www.destroyallsoftware.com/screencasts)

## Заключене

В этой главе мы рассмотрели несколько довольно важных тем. До сих пор мы не обсуждали непосредственно рабочий процесс, но теперь у вас есть варианты. Вы можете выбрат наиболее подходящий способ для вас и вашей команды создавать четкую и понятную документацию используя спеки, используя подробные техники как мы делали в главе 3, или более короткие варианты как было опасано в этой главе. Так же у вас есть разные варианты для работы с тестовыми данными — моки и стабы, фабрики, базовые Ruby объекты и любые их комбинации. Теперь вы знаете несколько разных техник для запуска и загрузки ваших тестов. Мы уже крепко встали на путь владения RSpec.

Мы уже на финишной прямой! Осталось закрыть еще немного тем, затем попробуем в целом осмыслить процесс тестирования что бы избежать типичных ловушек. Но перед этим заглянем в еще парочку мест типичного вэб приложение, в которых мы еще не были.
